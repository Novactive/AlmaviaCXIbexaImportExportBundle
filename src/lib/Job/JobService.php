<?php

declare(strict_types=1);

namespace AlmaviaCX\Bundle\IbexaImportExport\Job;

use AlmaviaCX\Bundle\IbexaImportExport\Execution\Execution;
use AlmaviaCX\Bundle\IbexaImportExport\Execution\ExecutionRecord;
use AlmaviaCX\Bundle\IbexaImportExport\Execution\ExecutionRepository;
use DateTimeImmutable;
use Doctrine\Common\Collections\Collection;
use Doctrine\Common\Collections\Selectable;
use Ibexa\Contracts\Core\SiteAccess\ConfigResolverInterface;

/**
 * @SuppressWarnings("PHPMD.TooManyPublicMethods")
 */
class JobService
{
    public function __construct(
        protected JobRepository $jobRepository,
        protected ExecutionRepository $executionRepository,
        protected JobRunnerInterface $jobRunner,
        protected JobDebugger $jobDebugger,
        protected ConfigResolverInterface $configResolver
    ) {
    }

    public function createJob(Job $job, bool $autoStart = false): void
    {
        $job->setRequestedDate(new DateTimeImmutable());
        $this->jobRepository->save($job);

        if ($autoStart) {
            $this->runJob($job);
        }
    }

    public function runJob(Job $job, int $batchLimit = null, bool $reset = false): int
    {
        if (!$batchLimit) {
            $batchLimit = $this->configResolver->getParameter('default_batch_limit', 'import_export');
        }

        return ($this->jobRunner)($job, $batchLimit, $reset);
    }

    public function runExecution(Execution $execution, int $batchLimit = null): void
    {
        if (!$batchLimit) {
            $batchLimit = $this->configResolver->getParameter('default_batch_limit', 'import_export');
        }

        $this->jobRunner->runExecution($execution, $batchLimit);
    }

    public function pauseJobExecution(Execution $execution): void
    {
        $execution->setStatus(Execution::STATUS_FORCE_PAUSED);
        $this->executionRepository->save($execution);
    }

    public function cancelJobExecution(Execution $execution): void
    {
        $execution->setStatus(Execution::STATUS_CANCELED);
        $this->executionRepository->save($execution);
    }

    public function debugJobExecution(Execution $execution, int $index): void
    {
        ($this->jobDebugger)($execution, $index);
    }

    public function loadJobById(int $id): ?Job
    {
        return $this->jobRepository->findById($id);
    }

    public function countJobs(): int
    {
        return $this->jobRepository->count([]);
    }

    /**
     * @param $limit
     * @param $offset
     *
     * @return Job[]
     */
    public function loadJobs(int $limit = 10, int $offset = 0): array
    {
        return $this->jobRepository->findBy(
            [],
            ['requestedDate' => 'DESC', 'id' => 'DESC'],
            $limit,
            $offset
        );
    }

    public function delete(Job $job): void
    {
        $this->jobRepository->delete($job);
    }

    /**
     * @return Collection<string, ExecutionRecord>|Selectable<string, ExecutionRecord>
     */
    public function getJobExecutionLogs(Execution $execution, ?int $level = null): Collection|Selectable
    {
        if (!$level) {
            return $execution->getLoggerRecords();
        }

        return $execution->getRecordsForLevel($level);
    }

    /**
     * @throws \Doctrine\DBAL\Driver\Exception
     *
     * @return array<int, int>
     */
    public function getJobExecutionLogsCountByLevel(Execution $execution): array
    {
        return $this->executionRepository->getExecutionLogsCountByLevel($execution->getId());
    }
}
